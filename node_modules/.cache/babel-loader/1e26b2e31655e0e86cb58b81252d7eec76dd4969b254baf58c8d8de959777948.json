{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) => {\n  return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n    const audioTracks = mediaStream.getAudioTracks();\n    const bufferedArrayBuffers = [];\n    // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n    const channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    let promisedPartialRecording = null;\n    let stopRecording = () => {}; // tslint:disable-line:no-empty\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n      if (nativeMediaRecorder.state === 'inactive') {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n    const stop = () => {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n      stopRecording();\n      stopRecording = () => {}; // tslint:disable-line:no-empty\n      nativeMediaRecorder.stop();\n    };\n    nativeMediaRecorder.addEventListener('error', () => {\n      stop();\n      // Bug #3 & #4: Chrome throws an error event without any error.\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n      pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start(timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        if (nativeMediaRecorder.state === 'inactive') {\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n          let isRecording = false;\n          let isStopped = false;\n          // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n          let pendingInvocations = 0;\n          let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n          stopRecording = () => {\n            isStopped = true;\n          };\n          const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(_ref => {\n            let {\n              data\n            } = _ref;\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async _ref2 => {\n              let {\n                dataView = null,\n                elementType = null,\n                encoderId,\n                port\n              } = _ref2;\n              const arrayBuffer = await data.arrayBuffer();\n              pendingInvocations -= 1;\n              const currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n              if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n                if (lengthAndValue === null) {\n                  return {\n                    dataView: currentDataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n                const {\n                  value\n                } = lengthAndValue;\n                if (value !== 172351395) {\n                  return {\n                    dataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n                isRecording = true;\n              }\n              const {\n                currentElementType,\n                offset,\n                contents\n              } = decodeWebMChunk(currentDataView, elementType, channelCount);\n              const remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n              contents.forEach(content => port.postMessage(content, content.map(_ref3 => {\n                let {\n                  buffer\n                } = _ref3;\n                return buffer;\n              })));\n              if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                encode(encoderId, null).then(arrayBuffers => {\n                  dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event('stop'));\n                });\n                port.postMessage([]);\n                port.close();\n                removeEventListener();\n              }\n              return {\n                dataView: remainingDataView,\n                elementType: currentElementType,\n                encoderId,\n                port\n              };\n            });\n          });\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(_ref4 => {\n              let {\n                encoderId\n              } = _ref4;\n              return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            });\n          }\n        }\n        nativeMediaRecorder.start(100);\n      },\n      stop\n    };\n  };\n};","map":{"version":3,"names":["encode","instantiate","MultiBufferDataView","on","createWebmPcmMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createNotSupportedError","decodeWebMChunk","readVariableSizeInteger","eventTarget","nativeMediaRecorderConstructor","mediaStream","mimeType","audioTracks","getAudioTracks","bufferedArrayBuffers","channelCount","length","undefined","getSettings","nativeMediaRecorder","sampleRate","promisedPartialRecording","stopRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","encoderId","timeslice","state","push","stop","catch","addEventListener","ErrorEvent","error","Event","pause","resume","start","getVideoTracks","Error","isRecording","isStopped","pendingInvocations","promisedDataViewElementTypeEncoderIdAndPort","removeEventListener","_ref","then","_ref2","dataView","elementType","port","arrayBuffer","currentDataView","buffers","byteOffset","lengthAndValue","value","currentElementType","offset","contents","remainingDataView","byteLength","forEach","content","postMessage","map","_ref3","buffer","close","_ref4"],"sources":["/Users/neelpatel/Desktop/react_application/pushup_counter/node_modules/extendable-media-recorder/src/factories/webm-pcm-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nimport { TPromisedDataViewElementTypeEncoderIdAndPort, TRecordingState, TWebmPcmMediaRecorderFactoryFactory } from '../types';\n\nexport const createWebmPcmMediaRecorderFactory: TWebmPcmMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createNotSupportedError,\n    decodeWebMChunk,\n    readVariableSizeInteger\n) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount =\n            audioTracks.length === 0\n                ? undefined\n                : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount;\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n\n        let promisedPartialRecording: null | Promise<void> = null;\n        let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const stop = (): void => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n\n            stopRecording();\n            stopRecording = () => {}; // tslint:disable-line:no-empty\n\n            nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', () => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n        });\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return nativeMediaRecorder.state;\n            },\n\n            pause(): void {\n                return nativeMediaRecorder.pause();\n            },\n\n            resume(): void {\n                return nativeMediaRecorder.resume();\n            },\n\n            start(timeslice?: number): void {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort: TPromisedDataViewElementTypeEncoderIdAndPort = instantiate(\n                        mimeType,\n                        sampleRate\n                    );\n\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n\n                    const removeEventListener = on(\n                        nativeMediaRecorder,\n                        'dataavailable'\n                    )(({ data }) => {\n                        pendingInvocations += 1;\n\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(\n                            async ({ dataView = null, elementType = null, encoderId, port }) => {\n                                const arrayBuffer = await data.arrayBuffer();\n\n                                pendingInvocations -= 1;\n\n                                const currentDataView =\n                                    dataView === null\n                                        ? new MultiBufferDataView([arrayBuffer])\n                                        : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n                                if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                    const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                                    if (lengthAndValue === null) {\n                                        return { dataView: currentDataView, elementType, encoderId, port };\n                                    }\n\n                                    const { value } = lengthAndValue;\n\n                                    if (value !== 172351395) {\n                                        return { dataView, elementType, encoderId, port };\n                                    }\n\n                                    isRecording = true;\n                                }\n\n                                const { currentElementType, offset, contents } = decodeWebMChunk(\n                                    currentDataView,\n                                    elementType,\n                                    channelCount\n                                );\n                                const remainingDataView =\n                                    offset < currentDataView.byteLength\n                                        ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                        : null;\n\n                                contents.forEach((content) =>\n                                    port.postMessage(\n                                        content,\n                                        content.map(({ buffer }) => buffer)\n                                    )\n                                );\n\n                                if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                    encode(encoderId, null).then((arrayBuffers) => {\n                                        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                                        bufferedArrayBuffers.length = 0;\n\n                                        eventTarget.dispatchEvent(new Event('stop'));\n                                    });\n\n                                    port.postMessage([]);\n                                    port.close();\n\n                                    removeEventListener();\n                                }\n\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                            }\n                        );\n                    });\n\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(\n                            ({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice))\n                        );\n                    }\n                }\n\n                nativeMediaRecorder.start(100);\n            },\n\n            stop\n        };\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}